{
  "hash": "1a6a999494a6d82388f7da52771f4fb5",
  "result": {
    "markdown": "---\ntitle: \"Reticulate handling of NA's - 2nd edition\"\nauthor: Daniel Falbel\ndate: \"2023-08-15\"\n---\n\n\n[In a previous blogpost](https://dfalbel.github.io/posts/reticulate-nas/) we discussed how reticulate handles NA's when converting \nR data.frame columns into pandas data.frames.\n\nTurns out we missed one important point that came up when implementing [#1439](https://github.com/rstudio/reticulate/pull/1439). When converting R data.frames\nto Pandas data.frames and back, we know that each column is (or at least in most cases)\nsupposed to be a Pandas Series (AKA Numpy array) when in Python and a atomic R vector\nin R. Meaning that columns elements are homogeneous, in the sense that all elements\nhave the same data type. In Pandas that's not always true, because it's common to represent\nstring columns with 'object' data types, that can actually have mixed data types. In R, that's also\nnot always true because of list columns. But the point is, we know that we almost surely\nwants to simplify the column to a single data type if that's possible.\n\nHowever, there's another scenario that reticulate must think about `NA`s. That's the\ncase when converting R atomic vectors into Python objects. When outside of the data.frames\ncontext, reticulate converts R atomic vectors to Python lists. When casting back Python lists\ninto R, we simplify that list if it has homogeneous data types into an atomic vector. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reticulate)\nx <- r_to_py(1:10)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n:::\n\n```{.r .cell-code}\npy_to_r(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\nBoth casting to a Python list and simplifying when back to R are very useful in\npractical situations. Without them, most reticulate codebases would live with a\nbunch of `as.list`, `as.numeric`, `as.character` calls all the time. One could\nargue that this is safer alternative, but it's also too late to change this behavior.\n\nWhat happens then if the R atomic vector includes NA's?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_to_py(c(NA, TRUE, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[True, True, False]\n```\n:::\n\n```{.r .cell-code}\nr_to_py(c(NA_integer_, 1:5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[-2147483648, 1, 2, 3, 4, 5]\n```\n:::\n\n```{.r .cell-code}\nr_to_py(c(NA_real_, 0.1, 0.2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[nan, 0.1, 0.2]\n```\n:::\n\n```{.r .cell-code}\nr_to_py(c(NA_character_, \"hello\", \"world\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['NA', 'hello', 'world']\n```\n:::\n:::\n\n\nPython doesn't have a built-in `NA` value, and reticulate doesn't do anything to\nmake sure that R `NA`s are correctly represented in Python. For 3 types of atomic vectors\nreticulate destroys the `NA` information when representing the value in Python, which\nis really unexpected for users - see issue [#197](https://github.com/rstudio/reticulate/issues/197).\n\nOne possibility is to replace `NA`s. with `None` in the resulting Python list, so\nfor example, we would have:\n\n```r\nr_to_py(c(NA, TRUE, FALSE))\n#> [None, True, False]\n```\n\nIMO this is a good enough alternative. However, it's ambiguous to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_to_py(list(NULL, TRUE, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[None, True, False]\n```\n:::\n:::\n\n\nAnd it also breaks `py_to_r` simplification rules, so the round trip would result in:\n\n```r\nx <- r_to_py(c(NA, TRUE, FALSE))\npy_to_r(x)\n\n#> [[1]]\n#> NULL\n#> \n#> [[2]]\n#> [1] TRUE\n#> \n#> [[3]]\n#> [1] FALSE\n```\n\nOk, we could cause this to simplify into a logical vector if we detect it's homegenous\nexcept for the `None`, but then, what should we do with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npy_run_string(\"[None, None]\") # Should this become a logical vector?\n```\n:::\n\n\nAlso are we OK with breaking the round trip casts of `list(NULL, TRUE, FALSE)`?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}