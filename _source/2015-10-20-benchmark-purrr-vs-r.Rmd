---
layout: post
title: 'Benchmark do pacote purrr e funções naturais do base R'
date : 2015-10-20
tags: [r, pacotes, purrr, base]
--- 

No mês passado o Hadley fez o lançamento de uma nova versão do pacote `purrr`, este pacote tem como objetivo completar a interface de programação funcional do R. Desta forma, tudo que o `purrr` faz, também pode ser feito usando o `base` R, porém com um código muito maior. Surgiu, então, a pergunta: o que é mais rápido? `purrr` ou `base`?

Antes de ver os resultados, vale ressaltar que este é apenas um teste de velocidade. Tão, ou mais importante do que a velocidade está leitura do código e a consistência da interface. Então não use isso para aprender um ou outro jeito de fazer.

No teste vamos usar os seguintes pacotes:

```{r}
library(microbenchmark)
library(purrr)
```


## Map

```{r}
vetor <- 1:100
microbenchmark(
  purr = map(vetor, sqrt),
  base_lapply = lapply(vetor, sqrt),
  base_funprog = Map(sqrt, vetor)
)
```

Observamos que nesta operação, os dois métodos usando as funções `base` tiveram resultados parecidos (apesar do `lapply` ser um pouco mais rápido), o `purrr::map` teve velocidade um pouco menos que 4x pior.

Abaixo está a verificação de que as três formas retornam exatamente o mesmo resultado.

```{r}
purr <- map(vetor, sqrt)
base_lapply <- lapply(vetor, sqrt)
base_funprog <- Map(sqrt, vetor)

identical(purr, base_lapply)
identical(purr, base_funprog)
identical(base_lapply, base_funprog)
```

Agora vamos comparar `base` e `purrr` quando simplificamos os resultados para um vetor de números.

```{r}
microbenchmark(
  purr = map_dbl(vetor, sqrt),
  base_lapply = unlist(lapply(vetor, sqrt)),
  base_sqrt = sqrt(vetor)
)
```

Veja então que ao usar a versão `map_dbl` que simplifica os resultados para um vetor numérico do R, a versão usando `lapply` e usando o `purrr` tornam-se equivalentes.

Obviamente, a versão vetorizada de `sqrt` é muito mais rápida.

```{r}
purr <- map_dbl(vetor, sqrt)
base_lapply <- unlist(lapply(vetor, sqrt))
base_sqrt <- sqrt(vetor)
identical(purr, base_lapply)
identical(purr, base_sqrt)
identical(base_lapply, base_sqrt)
```

Enfim, concluí que usando `purr::map`, sabendo qual é a classe do objeto retornado conseguimos praticamente a mesma performance do `base`.

## Reduce

Reduce aplica uma função binária recursivamente por um vetor ou lista. Um exemplo simples de uso pode ser encontrar a soma de todos elementos de um vetor. Faremos aqui então de duas maneiras: usando o `base::Reduce` e o `purrr::reduce`.


```{r}
vetor <- 1:100
microbenchmark(
  base::Reduce(sum, vetor),
  purrr::reduce(vetor, sum)
)
```

Veja que neste caso o `purrr::reduce` foi um menos de 2x mais lento.

Vejamos um exemplo um pouco mais complexo em que temos uma lista de vetores numéricos e queremos encontrar os valores que aparecem em todas os vetores.

```{r}
l <- replicate(5, sample(1:10, 15, replace = T), simplify = FALSE)
str(l)

microbenchmark(
  base::Reduce(intersect, l),
  purrr::reduce(l, intersect)
)
```

Note que agora a performance das duas abordagens fica muito parecida, o `purrr` sendo muito pouco mais lento.

## Conclusão

Ainda não comparei todas as funções do `purrr` com as funções equivalentes do `base`, mas o que deu para perceber é que para operações muito simples o `base` se sai melhor. No entanto, quando as operações são mais complexas, as duas abordagens tornam-se equivalentes em termos de velocidade.








