---
layout: post
title: 'Seleção de hiperparâmetros do Random Forest'
date : 2016-05-31
tags: [modelagem, randomForest]
--- 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = F)
```

Neste post vou apresentar a mecânica de modelagem usando as funções do pacote `purrr`.
Para isso vamos utilizar o banco de dados [MINIST](http://yann.lecun.com/exdb/mnist/) que foi obtido, já processado, [nesta competição do Kaggle](https://www.kaggle.com/c/digit-recognizer). O objetivo será criar um modelo de **random forest** para prever, a partir dos pixels da imagem, o número que está escrito.

![minist](/images/mnistExamples.png)

Cada uma das imagens do banco de dados está representada por uma linha que contém a informação do valor dos seus 784 pixels. Além disso a base fornecida na competição já
possuia o label (coluna que indica o valor escrito na imagem).

A leitura dos dados pode ser realizada da seguinte forma pois eles estão disponíveis no [repositório do blog no github](https://github.com/dfalbel/dfalbel.github.io/tree/master/data).

```{r leitura}
library(purrr)
dados <- read.csv("https://github.com/dfalbel/dfalbel.github.io/raw/master/data/train.csv")
```

## Separação em base de construção e validação

O primeiro passo do processo de modelagem é separar a base em dois. A base de treino
que será utilizada na construção do modelo e a base de validação que só será utilizada
no final para a verificação da consistência do algoritmo, e para avaliação da
performance esperada em uma nova base.

Usaremos 70% da base para construção e os outros 30% para validação.

```{r separacao}
train_i <- sample(1:nrow(dados), size = nrow(dados)*0.7, replace = FALSE)
train <- dados[train_i,]
test <- dados[-train_i,]
```

## Seleção dos hiperparâmetros

O modelo escolhido foi o **random forest**, este modelo possui os seguintes **hiperparâmetros** que chamaremos de **ntree**, **mtry**, **sampsize** e **nodesize**. Eles possuem o seguinte significado:

- **ntree** número de árvores que serão construídas.
- **mtry** número de variáveis que serão aleatóriamente escolhidas como candidados cada quebra.
- **sampsize** tamanho da amostra usado para treinar cada uma das árvores. [Esta pergunta](http://stats.stackexchange.com/a/24914/44359) do [Cross Validated](http://stats.stackexchange.com/) possui uma boa discussão sobre o efeito desse parâmetro no resultado do modelo.
- **nodesize** mínimo tamanho dos nós. Queremos 'nós' não muito pequenos para evitar *superajuste*, mas também nãow queremos nós muito grandes para não perdermos performance. 

A seleção dos *hiperparâmetros* será feita usando cross-validation de 10 partes.

### Definição do Grid

Em primeiro lugar definimos um grid de parâmetros que iremos testar na validação
cruzada. Não vamos variar os valores do `sampsize` nem do `nodesize` uma vez que 
eles dependem um pouco do tamanho da amostra.

```{r grid}
grid <- expand.grid(
  ntree = c(1400 + 150*(-7:7)),
  mtry = floor(sqrt(ncol(train))) + 5*(-2:8) 
)
```

Como o padrão da função `randomForest` do `R` é `ntree = 500` e `mtry = floor(sqrt(ncol(train))`, variei os parâmetros no grid em torno disso. 

### Separação dos índices de validação cruzada

A seguir separamos os índices que serão usados em cada uma das construções
e validações, no processo de Cross Validation.

```{r crossvalidation}
grupos <- sample(1:10, size = nrow(train), replace = T)
indices_cv <- 1:10 %>% map(function(x){
  list(
    train = which(grupos != x), 
    test = which(grupos == x)
  )
})
```

Agora vamos definir uma função que treina um modelo para cada indice e já o valida nos índices de validação.

```{r}
treinar <- function(indices_cv, train, ntree = 500, mtry = 28){
  modelo <- randomForest(label ~ ., replace = T,
                         ntree = ntree, mtry = mtry, 
                         data = train[indices_cv$train, ]
                         )
  pred <- predict(modelo, newdata = train[indices_cv$test, ])
  accuracy <- sum(pred == train$label[indices_cv$test])/lenght(pred)
  return(accuracy)
}
res <- laply(indices_cv, treinar, train, .progress = "text")
```












